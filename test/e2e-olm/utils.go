package e2e

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"time"

	"github.com/ViaQ/logerr/kverrors"
	// . "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/api/resource"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/types"
	"k8s.io/apimachinery/pkg/util/wait"
	"sigs.k8s.io/controller-runtime/pkg/client"

	// "github.com/openshift/elasticsearch-operator/internal/utils"
	loggingv1 "github.com/openshift/elasticsearch-operator/apis/logging/v1"
	"github.com/openshift/elasticsearch-operator/test/utils"
	// "github.com/openshift/elasticsearch-operator/internal/k8shandler"
)

const (
	retryInterval        = time.Second * 3
	timeout              = time.Second * 600
	duration             = time.Second * 10
	interval             = time.Millisecond * 250
	cleanupRetryInterval = time.Second * 3
	cleanupTimeout       = time.Second * 30
	elasticsearchCRName  = "elasticsearch"
	kibanaCRName         = "kibana"
	exampleSecretsPath   = "/tmp/example-secrets"
)

func elasticsearchNameFor(uuid string) string {
	return fmt.Sprintf("%s-%s", elasticsearchCRName, uuid)
}

func createElasticsearchCR(ctx context.Context, esUUID, dataUUID string, replicas int) (*loggingv1.Elasticsearch, error) {
	namespace := operatorNamespace

	cpuValue := resource.MustParse("256m")
	memValue := resource.MustParse("1Gi")

	storageClassSize := resource.MustParse("2Gi")

	esDataNode := loggingv1.ElasticsearchNode{
		Roles: []loggingv1.ElasticsearchNodeRole{
			loggingv1.ElasticsearchRoleClient,
			loggingv1.ElasticsearchRoleData,
			loggingv1.ElasticsearchRoleMaster,
		},
		Storage: loggingv1.ElasticsearchStorageSpec{
			Size: &storageClassSize,
		},
		NodeCount: int32(replicas),
		GenUUID:   &dataUUID,
	}

	// create elasticsearch custom resource
	cr := &loggingv1.Elasticsearch{
		TypeMeta: metav1.TypeMeta{
			Kind:       "Elasticsearch",
			APIVersion: loggingv1.GroupVersion.String(),
		},
		ObjectMeta: metav1.ObjectMeta{
			Name:      elasticsearchNameFor(esUUID),
			Namespace: namespace,
			Annotations: map[string]string{
				"loggingv1.openshift.io/develLogAppender": "console",
				"loggingv1.openshift.io/loglevel":         "trace",
			},
		},
		Spec: loggingv1.ElasticsearchSpec{
			Spec: loggingv1.ElasticsearchNodeSpec{
				Image: "",
				Resources: corev1.ResourceRequirements{
					Limits: corev1.ResourceList{
						corev1.ResourceMemory: resource.MustParse("5Gi"),
					},
					Requests: corev1.ResourceList{
						corev1.ResourceCPU:    cpuValue,
						corev1.ResourceMemory: memValue,
					},
				},
			},
			Nodes: []loggingv1.ElasticsearchNode{
				esDataNode,
			},
			ManagementState:  loggingv1.ManagementStateManaged,
			RedundancyPolicy: loggingv1.ZeroRedundancy,
		},
	}

	fmt.Printf("Creating Elasticsearch CR: %v\n", cr)
	Expect(k8sClient.Create(ctx, cr)).Should(Succeed())
	return cr, nil
}

func updateElasticsearchSpec(ctx context.Context, desired *loggingv1.Elasticsearch) error {
	return wait.Poll(retryInterval, timeout, func() (bool, error) {
		current := &loggingv1.Elasticsearch{}
		key := client.ObjectKey{Name: desired.GetName(), Namespace: desired.GetNamespace()}

		if err := k8sClient.Get(ctx, key, current); err != nil {
			if apierrors.IsNotFound(kverrors.Root(err)) {
				// Stop retry because CR not found
				return false, err
			}

			// Transient error retry
			return false, nil
		}

		current.Spec = desired.Spec

		fmt.Printf("Update Spec: %#v\n", current.Spec)

		if err := k8sClient.Update(ctx, current); err != nil {
			if apierrors.IsConflict(kverrors.Root(err)) {
				// Retry update because resource needs to get updated
				return false, nil
			}

			// Stop retry not recoverable error
			return false, err
		}

		return true, nil
	})
}

// Create the secret that would be generated by CLO normally
func createElasticsearchSecret(ctx context.Context, uuid string) error {
	fmt.Println("Creating required secret")

	if err := generateCertificates(operatorNamespace, uuid); err != nil {
		return err
	}

	elasticsearchSecret := utils.Secret(
		elasticsearchNameFor(uuid),
		operatorNamespace,
		map[string][]byte{
			"elasticsearch.key": getCertificateContents("elasticsearch.key", uuid),
			"elasticsearch.crt": getCertificateContents("elasticsearch.crt", uuid),
			"logging-es.key":    getCertificateContents("logging-es.key", uuid),
			"logging-es.crt":    getCertificateContents("logging-es.crt", uuid),
			"admin-key":         getCertificateContents("system.admin.key", uuid),
			"admin-cert":        getCertificateContents("system.admin.crt", uuid),
			"admin-ca":          getCertificateContents("ca.crt", uuid),
		},
	)

	fmt.Printf("Creating secret %s/%s\n", elasticsearchSecret.Namespace, elasticsearchSecret.Name)

	err := k8sClient.Create(ctx, elasticsearchSecret)
	if err != nil {
		return kverrors.Wrap(err, "failed to create elasticsearch secret",
			"name", elasticsearchSecret.Name,
			"namespace", elasticsearchSecret.Namespace)
	}

	return nil
}

func updateElasticsearchSecret(ctx context.Context, uuid string) error {
	namespace := operatorNamespace

	elasticsearchSecret := &corev1.Secret{}

	name := elasticsearchNameFor(uuid)
	secretName := types.NamespacedName{Name: name, Namespace: namespace}

	if err := k8sClient.Get(ctx, secretName, elasticsearchSecret); err != nil {
		return kverrors.Wrap(err, "failed to get secret",
			"name", secretName,
			"namespace", namespace)
	}

	elasticsearchSecret.Data = map[string][]byte{
		"elasticsearch.key": getCertificateContents("elasticsearch.key", uuid),
		"elasticsearch.crt": getCertificateContents("elasticsearch.crt", uuid),
		"logging-es.key":    getCertificateContents("logging-es.key", uuid),
		"logging-es.crt":    getCertificateContents("logging-es.crt", uuid),
		"admin-key":         getCertificateContents("system.admin.key", uuid),
		"admin-cert":        getCertificateContents("system.admin.crt", uuid),
		"admin-ca":          getCertificateContents("ca.crt", uuid),
		"dummy":             []byte("blah"),
	}

	fmt.Println("Updating required secret...")
	err := k8sClient.Update(ctx, elasticsearchSecret)
	if err != nil {
		return err
	}

	return nil
}

func createKibanaCR(namespace string) *loggingv1.Kibana {
	cpuValue, _ := resource.ParseQuantity("100m")
	memValue, _ := resource.ParseQuantity("256Mi")

	return &loggingv1.Kibana{
		ObjectMeta: metav1.ObjectMeta{
			Name:      "kibana",
			Namespace: namespace,
		},
		Spec: loggingv1.KibanaSpec{
			ManagementState: loggingv1.ManagementStateManaged,
			Replicas:        1,
			Resources: &corev1.ResourceRequirements{
				Limits: corev1.ResourceList{
					corev1.ResourceMemory: memValue,
				},
				Requests: corev1.ResourceList{
					corev1.ResourceCPU:    cpuValue,
					corev1.ResourceMemory: memValue,
				},
			},
		},
	}
}

func createKibanaSecret(ctx context.Context, esUUID string) error {
	namespace := operatorNamespace

	kibanaSecret := utils.Secret(
		kibanaCRName,
		namespace,
		map[string][]byte{
			"key":  getCertificateContents("system.logging.kibana.key", esUUID),
			"cert": getCertificateContents("system.logging.kibana.crt", esUUID),
			"ca":   getCertificateContents("ca.crt", esUUID),
		},
	)

	err := k8sClient.Create(context.TODO(), kibanaSecret)
	if err != nil {
		return err
	}

	return nil
}

func createKibanaProxySecret(ctx context.Context, esUUID string) error {
	namespace := operatorNamespace

	kibanaProxySecret := utils.Secret(
		fmt.Sprintf("%s-proxy", kibanaCRName),
		namespace,
		map[string][]byte{
			"server-key":     getCertificateContents("kibana-internal.key", esUUID),
			"server-cert":    getCertificateContents("kibana-internal.crt", esUUID),
			"session-secret": []byte("TG85VUMyUHBqbWJ1eXo1R1FBOGZtYTNLTmZFWDBmbkY="),
		},
	)

	err := k8sClient.Create(context.TODO(), kibanaProxySecret)
	if err != nil {
		return err
	}

	return nil
}

func generateCertificates(namespace, uuid string) error {
	fmt.Println("Generating required secret")
	workDir := fmt.Sprintf("%s/%s", exampleSecretsPath, uuid)
	storeName := elasticsearchNameFor(uuid)

	err := os.MkdirAll(workDir, os.ModePerm)
	if err != nil {
		return kverrors.Wrap(err, "failed to create certificate tmp dir",
			"dir", workDir)
	}
	cmd := exec.Command(projectRootDir+"/hack/cert_generation.sh", workDir, namespace, storeName)
	out, err := cmd.Output()
	if err != nil {
		return kverrors.Wrap(err, "failed to generate certificate",
			"store_name", storeName,
			"output", string(out))
	}

	return nil
}

func getProjectRootPath(projectRootDir string) string {
	fmt.Println("### getProjectRootPath is running")
	cwd, err := os.Getwd()
	cwdOrig := cwd
	if err != nil {
		panic(err)
	}
	for {
		if strings.HasSuffix(cwd, "/"+projectRootDir) {
			return cwd
		}
		lastSlashIndex := strings.LastIndex(cwd, "/")
		if lastSlashIndex == -1 {
			panic(cwdOrig + " did not contain /" + projectRootDir)
		}
		cwd = cwd[0:lastSlashIndex]
		fmt.Printf("cwd %v\n", cwd)
	}
}

func getCertificateContents(name, uuid string) []byte {
	filename := fmt.Sprintf("%s/%s/%s", exampleSecretsPath, uuid, name)
	return utils.GetFileContents(filename)
}
